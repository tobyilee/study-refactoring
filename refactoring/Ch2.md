[# 2장 리팩터링 원칙

## 리팩터링 정의

리팩터링 정의를 생각해봐야 하는 중요한 이유는 사실 이 용어를 대충 쓰기 때문이다.

행위가 유지되는 작은 단계를 적용해서 큰 변화를 가져오는 작업. 테스트가 없으면 행위가 유지되는지 확신할 수 없으니 리팩터링을 못하는 거겠지. 

**기능 추가 또는 변경과 리팩터링을 동시에 하고, 코드의 발전과 개선 등을 리팩터링이라는 용어로 통칭하기도 한다.**

> 리팩터링은 재구성(restructuring)의 특수한 형태. 

## 두 개의 모자

많이 소개된 비유인데 은근히 이걸 지키기가 어렵다. 기능을 추가하다가 뭔가 리팩터링 하고 싶기도 하고, 아직 테스트를 못 만들었는데 그냥 눈에 띄는 구조를 개선하기도 한다.

이 작은 스텝으로 개발하는 습관을 가지지 못하면 리팩터링은 대충 코드를 이리저리 만지면서 기능을 넣고 빼는 게 되버리겠지.

## 리팩터링의 이유

- 설계를 개선. 
  - 지속적인 개선이 없는 코드는 결국 나쁜 설계를 가진 코드가 되버리는데 이를 저지하려면 리팩터링이 필요하다. 
- 이해가 쉽게. 가독성이 좋게. 
  - 코드의 목적을 잘 설명하고 원하는 것을 분명하게 드러낼 수 있도록한다. 
  - 미래에도 확실하게 기억할 수 없는 것은 코드에 드러나도록 만들어야 한다. 왜 이렇게 만들었지???? 
- 버그 발견. 
  - 정상적인 작업을 수행하는 테스트로도 보이지 않는 숨은 버그는 코드를 정리하면서 드러나기도 한다. 대체로 모순이 보인다. 
- 개발 생산성을 높이려고.
  - 설계 지구력 가설. 뭐 지치지 않고 꾸준하게 할 수 있다는 면에서 지구력이기도 하지만, 이보다는 체력, 활력, 정신력 등으로 설명하는 것도 좋겠다. 
  - 요구사항이 바뀌고 예상하지 못했던 변경에 대응하는 능력을 키우는 것이 결국 장기적인 속도를 빠르게 만들겠지.

## 리팩터링 시점

- 예비적 리팩터링
  - 새로운 기능을 추가하기 직전. 기능을 추가하기 좋게 코드를 리팩터링한다. 
- 이해하기 쉽게 만드는 리팩터링
  - 이건 예비적 리팩터링보다 더 앞에서 할 수도 있고.
  - 혹은 기능을 추가한 뒤에도 해야 한다. 내 머리속에 있는 생각을 코드로 다 꺼내놓는다.
- 쓰레기 치우기
  - 눈에 보일 때마다, 혹은 체크해서 주기적으로, 여유가 생겼을 때. 
  - 시간이 걸리는 작업은 task로 추가해두고 진행한다. 근데 계속 우선순위가 밀리면...

위 세 가지 리팩터링은 기회가 생길 때마다 하는 리팩터링이다. 개발 과정에 녹아드는 리팩터링. 
리팩터링과 개발이 분리된 활동이 아니라는. 

계획된, 날잡아서 하는 리팩터링이 나쁜 건 아니지만, 거기에 의존하면 곤란하겠다. 이건 뭔가 큰 변화가 필요할 때 진행할 수 있겠지. 기술 교체, 버전 업그레이드, 혹은 아키텍처의 변경.

> 리팩터링 스텝을 마치고 매번 커밋하라고 1장에서 얘기했지만, 실전에선 기능 추가를 위한 리팩터링이 필요한 경우, 이 맥락을 보존하기 위해서 하나의 커밋으로 
> 만들 수 있다. 이건 팀에서 적절한 가이드를 만들어야 한다. 그리고 커밋 메시지 바디에서 언급하는게 좋겠다. 아니라면 차라리 분리하자.
> 
> 기능이 들어갔는데 다른 개발자도 사용하는 구조를 바꿔버렸다. 공통 API의 이름을 변경했다. 이런 것은 문제가 될 수도 있으니까. 스텝의 크기를 결정하는 건 쉬운 문제가 아니다. 
 
- 오래 걸리는 리팩터링
  - 이건 종류에 따라서 날 잡아서 다 같이 하는 방식이 필요할 수도, 아니면 꾸준히 진행해야 할 수도 있겠다.
  - 라이브러리 변경은 전략을 잘 세우면 변경까지 가는 중간 단계를 얼마든지 유지할 수 있다. EJB->스프링 POJO로 바꾼 프랑스 국세청의 스프링 도입 사례
- 코드 리뷰와 리팩터링
  - 리뷰어가 작성자 없이 온라인으로 diff나 보면서 하는 PR 리뷰 모델은 가치가 매우 떨어지기도 한다.
  - 컨텍스트와 의도를 잘 담아서 PR 메시지를 작성하고, 가능한 짧은 단위로 PR을 만들어야 하는데, 리뷰가 늘어지면.. 
  - 또는 생각없이 승인하고 나중에 시비를 건다거나.
  - 리팩터링이 필요하다면 그리고 그게 아주 간단한 작업이 아니라면 이건 PP를 하면서 continuous code review를 하는게 필요하다.
  - 테크 리드나 시니어라면 이걸 상시 잘 해야할텐데. 
  - 혹은 코딩 스타일이나 기술 사용 방식, 설계에 대한 의견 대립 등이 있다면 팀이 함께 리뷰하면서 리팩터링 해보는 시간도 필요하다. 초반에 이걸 안 해두면 
    정말 제각각 멋대로 짠 코드가 남겠지. 리팩터링 조차도.
- 관리자가 좋아할 이야기로 만들어야겠지. 
- **리팩터링이 가치를 주는 상황이 아니라면 하지마!!!** 기능을 추가해야 하거나, 이해가 중요한 경우가 아니라면. 새로 짜는 게 나을 때도.

## 리팩터링 할 때의 문제

맹목적 클린코드 추구를 하지 말아야 한다. 이런 것 때문에 리팩터링도 안티가 생기자나. 

> **리팩터링은 경제적인 이유로 하는 것이다!**

여기서부터 리팩터링에서 CI가 왜 중요한지가 나오는데. 머지 헬을 만들지 않을려면 짧고 작게 개발하고 CI를 한다.
Feature toggle(flag)가 도움이 될 수도 있다. 오래 끌고 가지 않는다. 자주 머지하면서 검증한다.

테스트도 나오지. 리팩터링, CI, 테스트. 이 세 가지가 다 긴밀하게 연결되어 있다.

## 아키텍처, 얘그니
나쁜 아키텍처는 리팩터링하기 안 좋다.

## 성능
극단적인 성능을 추구하려고 이상한 짓을 해야하는 게 아니라면. 
튜닝하기 좋게 먼저 만들고 그리고 성능 최적화를 한다. 
어디서 들은 얘기 가지고 성능 타령하지 않는다. 직접 측정하고 판단하자. 
대체로 성능에 관한 미신이 많다. 인터페이스는 메소드 직접 호출보다 16배가 느리니 쓰지 말자...

나쁜 코드는 성능 측정이 어렵다. 하나의 메소드에서 많은 일을 하는데 어느 부분에서 성능에 문제가 있는지 파악하기 힘들지.

## 리팩터링 자동화
IDE의 리팩터링 기능을 잘 사용하자. 근데 이게 테스트를 만들지 않는 변명이 되면 안 된다. Rename 하나 잘못하면 코드가 엉망이 되기도 한다. 

AI는 생각보다 리팩터링에 대해서 잘 안다. 책 내용에 대해서 질문하면 답변도 잘 하고, 예제도 잘 만들어낸다. 하지만 전체 코드를 보면서 리팩터링하는 건 과연?
IDE의 각종 자동완성 기능, 제안 그리고 Copilot의 코드 완성 지원 등등은 빠른 리팩터링 작업에 도움이 되긴한다. 그리고 항상 옳지 않지만 
이런저런 제안을 해주기도 한다.

## 참고할 것

- [정오표](https://docs.google.com/document/d/1IP04YcBgwOfBexV1CPK3gLCr2gmQdPTas2pHcqPuCz4/edit?tab=t.0)
- 어떤 책이나 자료를 보면 좋을까.


